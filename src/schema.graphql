schema {
  query: StandaloneQuery
  mutation: StandaloneMutation
  subscription: StandaloneSubscription
}

type StandaloneQuery {
  stateQuery(
    # Offset block hash for query.
    hash: ByteString
  ): StateQuery!
  state(
    # The address of state to fetch from the chain.
    address: Address!

    # The hash of the block used to fetch state from chain.
    hash: ByteString
  ): ByteString
  transferNCGHistories(
    blockHash: ByteString!
    recipient: Address
  ): [TransferNCGHistoryType!]!
  keyStore: KeyStoreType
    @deprecated(
      reason: "Use `planet key` command instead.  https://www.npmjs.com/package/@planetarium/cli"
    )
  nodeStatus: NodeStatusType!
  chainQuery: ExplorerQuery! @deprecated(reason: "Use /graphql/explorer")

  # The validation method provider for Libplanet types.
  validation: ValidationQuery!

  # Check if the provided address is activated.
  activationStatus: ActivationStatusQuery!
    @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")

  # Get the peer's block chain state
  peerChainState: PeerChainStateQuery!
  goldBalance(
    # Target address to query
    address: Address!

    # Offset block hash for query.
    hash: ByteString
  ): String!
  nextTxNonce(
    # Target address to query
    address: Address!
  ): Long!
    @deprecated(
      reason: "The root query is not the best place for nextTxNonce so it was moved. Use transaction.nextTxNonce()"
    )
  getTx(
    # transaction id.
    txId: TxId!
  ): TransactionType
    @deprecated(
      reason: "The root query is not the best place for getTx so it was moved. Use transaction.getTx()"
    )

  # Address of current node.
  minerAddress: Address

  # Get monster collection status by address.
  monsterCollectionStatus(
    # agent address.
    address: Address
  ): MonsterCollectionStatusType

  # Query for transaction.
  transaction: TransactionHeadlessQuery!
  activated(invitationCode: String!): Boolean!
    @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")
  activationKeyNonce(invitationCode: String!): String!
    @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")

  # Query for rpc mode information.
  rpcInformation: RpcInformationQuery!

  # Query to create action transaction.
  actionQuery: ActionQuery!
  actionTxQuery(
    # The hexadecimal string of public key for Transaction.
    publicKey: String!

    # The nonce for Transaction.
    nonce: Long

    # The time this transaction is created.
    timestamp: DateTimeOffset
    maxGasPrice: FungibleAssetValueInputType = {
      quantity: 1000000000000000000
      ticker: "Mead"
      decimalPlaces: 18
      minters: null
    }
  ): ActionTxQuery!

  # Query to get derived address.
  addressQuery: AddressQuery!
}

type StateQuery {
  # State for avatar.
  avatar(
    # Address of avatar.
    avatarAddress: Address!
  ): AvatarStateType

  # Avatar states having some order as addresses
  avatars(
    # Addresses of avatars to query.
    addresses: [Address!]!
  ): [AvatarStateType]!

  # State for avatar EXP record.
  rankingMap(
    # RankingMapState index. 0 ~ 99
    index: Int!
  ): RankingMapStateType

  # State for shop.
  shop: ShopStateType
    @deprecated(
      reason: "Shop is migrated to ShardedShop and not using now. Use shardedShop() instead."
    )

  # State for sharded shop.
  shardedShop(
    # ItemSubType for shard. see from https://github.com/planetarium/lib9c/blob/main/Lib9c/Model/Item/ItemType.cs#L13
    itemSubType: ItemSubType!

    # Nonce for shard. It's not considered if itemSubtype is kind of costume or title. 0 ~ 15
    nonce: Int!
  ): ShardedShopStateV2Type

  # State for weekly arena.
  weeklyArena(
    # WeeklyArenaState index. It increases every 56,000 blocks.
    index: Int!
  ): WeeklyArenaStateType

  # List of arena information of requested arena and avatar list
  arenaInformation(
    # Championship ID to get arena information
    championshipId: Int!

    # Round of championship to get arena information
    round: Int!

    # List of avatar address to get arena information
    avatarAddresses: [Address!]!
  ): [ArenaInformationType!]!

  # State for agent.
  agent(
    # Address of agent.
    address: Address!
  ): AgentStateType

  # State for staking.
  stakeState(
    # Address of agent who staked.
    address: Address!
  ): StakeStateType

  # Staking states having same order as addresses
  stakeStates(
    # Addresses of agent who staked.
    addresses: [Address]!
  ): [StakeStateType]!

  # State for monster collection.
  monsterCollectionState(
    # Address of agent.
    agentAddress: Address!
  ): MonsterCollectionStateType
  monsterCollectionSheet: MonsterCollectionSheetType
  stakeRewards: StakeRewardsType
  crystalMonsterCollectionMultiplierSheet: CrystalMonsterCollectionMultiplierSheetType

  # List of unlocked equipment recipe sheet row ids.
  unlockedRecipeIds(
    # Address of avatar.
    avatarAddress: Address!
  ): [Int]

  # List of unlocked world sheet row ids.
  unlockedWorldIds(
    # Address of avatar.
    avatarAddress: Address!
  ): [Int]

  # world boss season user information.
  raiderState(
    # address of world boss season.
    raiderAddress: Address!
  ): RaiderStateType

  # world boss season id by block index.
  raidId(
    blockIndex: Long!

    # find previous raid id.
    prev: Boolean = false
  ): Int!

  # world boss season boss information.
  worldBossState(bossAddress: Address!): WorldBossStateType

  # user boss kill reward record by world boss season.
  worldBossKillRewardRecord(
    worldBossKillRewardRecordAddress: Address!
  ): WorldBossKillRewardRecordType

  # asset balance by currency.
  balance(
    address: Address!
    currency: CurrencyInput!
  ): FungibleAssetValueWithCurrencyType!

  # raider address list by world boss season.
  raiderList(raiderListAddress: Address!): [Address!]
  orderDigestList(avatarAddress: Address!): OrderDigestListStateType
  pledge(agentAddress: Address!): MeadPledgeType!

  # Get balances and fungible items in garages.
  # Use either `currencyEnums` or `currencyTickers` to get balances.
  garages(
    # Agent address to get balances and fungible items in garages
    agentAddr: Address!

    # List of currency enums to get balances in garages
    currencyEnums: [CurrencyEnum!]

    # List of currency tickers to get balances in garages
    currencyTickers: [String!]

    # List of fungible item IDs to get fungible item in garages
    fungibleItemIds: [String!]
  ): GaragesType
}

type AvatarStateType {
  # Address of avatar.
  address: Address!

  # Block index at the latest executed action.
  blockIndex: Int!

  # Character ID from CharacterSheet.
  characterId: Int!

  # Block index at the DailyReward execution.
  dailyRewardReceivedIndex: Long!

  # Address of agent.
  agentAddress: Address!

  # The index of this avatar state among its agent's avatar addresses.
  index: Int!

  # Block index at the latest executed action.
  updatedAt: Long!

  # Avatar name.
  name: String!

  # Avatar total EXP.
  exp: Int!

  # Avatar Level.
  level: Int!

  # Current ActionPoint.
  actionPoint: Int!

  # Index of ear color.
  ear: Int!

  # Index of hair color.
  hair: Int!

  # Index of eye color.
  lens: Int!

  # Index of tail color.
  tail: Int!

  # Avatar inventory.
  inventory: InventoryType!

  # Rune list of avatar
  runes: [RuneStateType!]!

  # Address list of combination slot.
  combinationSlotAddresses: [Address!]!

  # Combination slots.
  combinationSlots: [CombinationSlotStateType!]!

  # List of acquired item ID.
  itemMap: CollectionMapType!

  # List of quest event ID.
  eventMap: CollectionMapType!

  # List of defeated monster ID.
  monsterMap: CollectionMapType!

  # List of cleared stage ID.
  stageMap: CollectionMapType!

  # List of quest.
  questList: QuestListType!

  # List of mail.
  mailBox: MailBoxType!

  # World & Stage information.
  worldInformation: WorldInformationType!
}

scalar Address

scalar Long

type InventoryType {
  # List of Consumables.
  consumables: [ConsumableType!]!

  # List of Materials.
  materials: [MaterialType!]!

  # List of Equipments.
  equipments(
    # filter equipped inventory item
    equipped: Boolean
  ): [EquipmentType!]!

  # List of Costumes.
  costumes: [CostumeType!]!

  # List of Inventory Item.
  items(
    # An Id to find Inventory Item
    inventoryItemId: Int

    # filter locked Inventory Item
    locked: Boolean
  ): [InventoryItemType!]!
}

type ConsumableType {
  # Grade from ItemSheet.
  grade: Int!

  # ID from ItemSheet.
  id: Int!

  # Item category.
  itemType: ItemType!

  # Item subcategory.
  itemSubType: ItemSubType!

  # Item elemental.
  elementalType: ElementalType!
  requiredBlockIndex: Long
  itemId: Guid!
  mainStat: StatType!
}

enum ItemType {
  CONSUMABLE
  COSTUME
  EQUIPMENT
  MATERIAL
}

enum ItemSubType {
  FOOD
  FULL_COSTUME
  HAIR_COSTUME
  EAR_COSTUME
  EYE_COSTUME
  TAIL_COSTUME
  WEAPON
  ARMOR
  BELT
  NECKLACE
  RING
  EQUIPMENT_MATERIAL
  FOOD_MATERIAL
  MONSTER_PART
  NORMAL_MATERIAL
  HOURGLASS
  AP_STONE
  CHEST
    @deprecated(
      reason: "ItemSubType.Chest has never been used outside the MaterialItemSheet. And we won't use it in the future until we have a specific reason."
    )
  TITLE
  AURA
}

enum ElementalType {
  NORMAL
  FIRE
  WATER
  LAND
  WIND
}

scalar Guid

enum StatType {
  NONE
  HP
  ATK
  DEF
  CRI
  HIT
  SPD
  DRV
  DRR
  CDMG
  ARMOR_PENETRATION
  THORN
}

type MaterialType {
  # Grade from ItemSheet.
  grade: Int!

  # ID from ItemSheet.
  id: Int!

  # Item category.
  itemType: ItemType!

  # Item subcategory.
  itemSubType: ItemSubType!

  # Item elemental.
  elementalType: ElementalType!
  requiredBlockIndex: Long
  itemId: ByteString!
}

scalar ByteString

type EquipmentType {
  # Grade from ItemSheet.
  grade: Int!

  # ID from ItemSheet.
  id: Int!

  # Item category.
  itemType: ItemType!

  # Item subcategory.
  itemSubType: ItemSubType!

  # Item elemental.
  elementalType: ElementalType!
  requiredBlockIndex: Long
  setId: Int!
  stat: DecimalStatType!
  equipped: Boolean!
  itemId: Guid!
  level: Int!
  skills: [SkillType]
  buffSkills: [SkillType]
  statsMap: StatsMapType!
}

type DecimalStatType {
  statType: StatType!
  baseValue: Decimal!
  additionalValue: Decimal!
  totalValue: Decimal!
}

scalar Decimal

type SkillType {
  id: Int!
  elementalType: ElementalType!
  power: Int!
  chance: Int!
  statPowerRatio: Int!
  referencedStatType: StatType!
}

type StatsMapType {
  hP: Int!
  aTK: Int!
  dEF: Int!
  cRI: Int!
  hIT: Int!
  sPD: Int!
}

type CostumeType {
  # Grade from ItemSheet.
  grade: Int!

  # ID from ItemSheet.
  id: Int!

  # Item category.
  itemType: ItemType!

  # Item subcategory.
  itemSubType: ItemSubType!

  # Item elemental.
  elementalType: ElementalType!
  requiredBlockIndex: Long

  # Guid of costume.
  itemId: Guid!

  # Status of Avatar equipped.
  equipped: Boolean!
}

type InventoryItemType {
  # A count of item
  count: Int!

  # An Id of item
  id: Int!

  # An ItemType of item
  itemType: ItemType!
  locked: Boolean!
  lockId: Guid
  tradableId: Guid
}

type RuneStateType {
  # ID of rune.
  runeId: Int!

  # Level of this rune.
  level: Int!
}

type CombinationSlotStateType {
  # Address of combination slot.
  address: Address!

  # Block index at the combination slot can be usable.
  unlockBlockIndex: Long!

  # Stage id at the combination slot unlock.
  unlockStage: Int!

  # Block index at the combination started.
  startBlockIndex: Long!

  # Pet id used in equipment
  petId: Int
}

type CollectionMapType {
  count: Int!
  pairs: [[Int]!]!
}

type QuestListType {
  completedQuestIds: [Int!]!
}

type MailBoxType {
  count: Int!
  mails: [MailType!]!
}

type MailType {
  id: Guid!
  requiredBlockIndex: Long!
  blockIndex: Long!
}

type WorldInformationType {
  isStageCleared(stageId: Int!): Boolean!
  isWorldUnlocked(worldId: Int!): Boolean!
  world(worldId: Int!): WorldType!
}

type WorldType {
  id: Int!
  name: String!
  isUnlocked: Boolean!
  isStageCleared: Boolean!
  unlockedBlockIndex: Long!
  stageClearedBlockIndex: Long!
  stageBegin: Int!
  stageEnd: Int!
  stageClearedId: Int!
}

type RankingMapStateType {
  # Address of RankingMapState.
  address: Address!

  # RankingMapState Capacity.
  capacity: Int!

  # List of RankingInfo.
  rankingInfos: [RankingInfoType!]!
}

type RankingInfoType {
  # Avatar total EXP.
  exp: Long!

  # Avatar Level.
  level: Int!

  # Equipped Armor ID from EquipmentItemSheet.
  armorId: Int!

  # Block index at RankingInfo update.
  updatedAt: Long!

  # Block index at Latest stage cleared.
  stageClearedBlockIndex: Long!

  # Address of agent.
  agentAddress: Address!

  # Address of avatar.
  avatarAddress: Address!

  # Avatar name.
  avatarName: String!
}

type ShopStateType {
  # Address of shop.
  address: Address!

  # List of ShopItem.
  products(
    # Filter for item id.
    id: Int

    # Filter for ItemSubType. see from https://github.com/planetarium/lib9c/blob/main/Lib9c/Model/Item/ItemType.cs#L13
    itemSubType: ItemSubType

    # Filter for item maximum price.
    maximumPrice: Int
  ): [ShopItemType]!
}

type ShopItemType {
  # Address of seller agent.
  sellerAgentAddress: Address!

  # Address of seller avatar.
  sellerAvatarAddress: Address!

  # Guid of product registered.
  productId: Guid!

  # Item price.
  price: String!

  # Equipment / Consumable information.
  itemUsable: ItemUsableType

  # Costume information.
  costume: CostumeType
}

type ItemUsableType {
  # Grade from ItemSheet.
  grade: Int!

  # ID from ItemSheet.
  id: Int!

  # Item category.
  itemType: ItemType!

  # Item subcategory.
  itemSubType: ItemSubType!

  # Item elemental.
  elementalType: ElementalType!
  requiredBlockIndex: Long

  # Guid of item.
  itemId: Guid!
}

type ShardedShopStateV2Type {
  # Address of sharded shop.
  address: Address!

  # List of OrderDigest.
  orderDigestList(
    # Filter for item id.
    id: Int

    # Filter for item maximum price.
    maximumPrice: Int
  ): [OrderDigestType]!
}

type OrderDigestType {
  # Guid of order.
  orderId: Guid!

  # Tradable guid of order.
  tradableId: Guid!

  # Block index order started.
  startedBlockIndex: Int!

  # Block index order expired.
  expiredBlockIndex: Int!

  # Address of seller agent.
  sellerAgentAddress: Address!

  # Order price.
  price: String!
  combatPoint: Int!
  level: Int!

  # Id of item.
  itemId: Int!

  # Count of item.
  itemCount: Int!
}

type WeeklyArenaStateType {
  address: Address!
  ended: Boolean!
  orderedArenaInfos: [ArenaInfoType]!
}

type ArenaInfoType {
  agentAddress: Address!
  avatarAddress: Address!
  avatarName: String!
  arenaRecord: ArenaRecordType!
  active: Boolean!
  dailyChallengeCount: Int!
  score: Int!
}

type ArenaRecordType {
  win: Int
  lose: Int
  draw: Int
}

type ArenaInformationType {
  avatarAddress: Address!
  address: Address!
  win: Int!
  lose: Int!
  ticket: Int!
  ticketResetCount: Int!
  purchasedTicketCount: Int!
  score: Int!
}

type AgentStateType {
  # Address of agent.
  address: Address!

  # List of avatar.
  avatarStates: [AvatarStateType!]

  # Current NCG.
  gold: String!

  # Monster collection round of agent.
  monsterCollectionRound: Long!

  # Current monster collection level.
  monsterCollectionLevel: Long!
  hasTradedItem: Boolean!

  # Current CRYSTAL.
  crystal: String!

  # mead pledge information.
  pledge: MeadPledgeType!
}

type MeadPledgeType {
  patronAddress: Address
  approved: Boolean!
  mead: Int!
}

type StakeStateType {
  # The address of current state.
  address: Address!

  # The staked amount.
  deposit: String!

  # The block index the user started to stake.
  startedBlockIndex: Int!

  # The block index the user received rewards.
  receivedBlockIndex: Int!

  # The block index the user can cancel the staking.
  cancellableBlockIndex: Long!

  # The block index the user can claim rewards.
  claimableBlockIndex: Long!

  # The staking achievements.
  achievements: StakeAchievementsType!
}

type StakeAchievementsType {
  # The address of current state.
  achievementsByLevel(level: Int!): Int!
}

type MonsterCollectionStateType {
  address: Address!
  level: Long!
  expiredBlockIndex: Long!
  startedBlockIndex: Long!
  receivedBlockIndex: Long!
  rewardLevel: Long!
  claimableBlockIndex: Long!
}

type MonsterCollectionSheetType {
  orderedList: [MonsterCollectionRowType]
}

type MonsterCollectionRowType {
  level: Int!
  requiredGold: Int!
  rewards: [MonsterCollectionRewardInfoType]!
}

type MonsterCollectionRewardInfoType {
  itemId: Int!
  quantity: Int!
}

type StakeRewardsType {
  orderedList: [StakeRegularRewardsType!]!
}

type StakeRegularRewardsType {
  level: Int!
  requiredGold: Long!
  rewards: [StakeRegularRewardInfoType!]!
  bonusRewards: [StakeRegularFixedRewardInfoType!]!
}

type StakeRegularRewardInfoType {
  itemId: Int!
  rate: Int!
  type: StakeRewardType!
  currencyTicker: String
  currencyDecimalPlaces: Int
  decimalRate: Decimal!
}

enum StakeRewardType {
  ITEM
  RUNE
  CURRENCY
}

type StakeRegularFixedRewardInfoType {
  itemId: Int!
  count: Int!
}

type CrystalMonsterCollectionMultiplierSheetType {
  orderedList: [CrystalMonsterCollectionMultiplierRowType!]!
}

type CrystalMonsterCollectionMultiplierRowType {
  level: Int!
  multiplier: Int!
}

type RaiderStateType {
  # season total score.
  totalScore: Int!

  # season high score.
  highScore: Int!

  # season total challenge count.
  totalChallengeCount: Int!

  # remain challenge count before refill.
  remainChallengeCount: Int!

  # latest reward claimed season rank.
  latestRewardRank: Int!

  # challenge ticket purchase count.
  purchaseCount: Int!

  # combat point of avatar state.
  cp: Int!

  # level of avatar state.
  level: Int!

  # icon id for ranking portrait.
  iconId: Int!

  # latest challenge boss level.
  latestBossLevel: Int!

  # rank reward claimed block index.
  claimedBlockIndex: Long!

  # ticket refilled block index.
  refillBlockIndex: Long!

  # address of avatar state.
  avatarAddress: Address!

  # name of avatar state.
  avatarName: String!
}

type WorldBossStateType {
  # world boss season id.
  id: Int!

  # world boss current level.
  level: Int!

  # world boss current hp.
  currentHp: BigInt!

  # world boss season started block index.
  startedBlockIndex: Long!

  # world boss season ended block index.
  endedBlockIndex: Long!
}

scalar BigInt

type WorldBossKillRewardRecordType {
  map: [WorldBossKillRewardRecordMapType!]!
}

type WorldBossKillRewardRecordMapType {
  bossLevel: Int!

  # check reward already claimed. if already claimed return true.
  claimed: Boolean!
}

type FungibleAssetValueWithCurrencyType {
  currency: CurrencyType!
  quantity(minerUnit: Boolean = false): String!
}

type CurrencyType {
  ticker: String!
  decimalPlaces: Byte!
  minters: [Address]
}

scalar Byte

input CurrencyInput {
  # The ticker symbol, e.g., USD.
  ticker: String!

  # The number of digits to treat as minor units (i.e., exponents).
  decimalPlaces: Byte!

  # The addresses who can mint this currency.  If this is null anyone can mint the currency.  On the other hand, unlike null, an empty set means no one can mint the currency.
  minters: [Address!]
  maximumSupplyMajorUnit: BigInt
  maximumSupplyMinorUnit: BigInt

  # Whether the total supply of this currency is trackable.
  totalSupplyTrackable: Boolean
}

type OrderDigestListStateType {
  address: Address
  orderDigestList: [OrderDigestType]!
}

type GaragesType {
  agentAddr: Address
  garageBalancesAddr: Address
  garageBalances: [FungibleAssetValue]
  fungibleItemGarages: [FungibleItemGarageWithAddressType]
}

# Holds a fungible asset value which holds its currency together.
type FungibleAssetValue {
  # The currency of the fungible asset.
  currency: Currency!

  # Gets a number that indicates the sign (-1: negative, 1: positive, or 0: zero) of the value.
  sign: Int!
  majorUnit: BigInt!
  minorUnit: BigInt!

  # The value quantity without its currency in string, e.g., "123.45".
  quantity: String!

  # The value quantity with its currency in string, e.g., "123.45 ABC".
  string: String!
}

type Currency {
  # The ticker symbol, e.g., USD.
  ticker: String!

  # The number of digits to treat as minor units (i.e., exponents).
  decimalPlaces: Byte!

  # The addresses who can mint this currency.  If this is null anyone can mint the currency.  On the other hand, unlike null, an empty set means no one can mint the currency.
  minters: [Address!]

  # The uppermost quantity of currency allowed to exist.  null means unlimited supply.
  maximumSupply: FungibleAssetValue

  # Whether the total supply of this currency is trackable.
  totalSupplyTrackable: Boolean!

  # The deterministic hash derived from other fields.
  hash: ByteString!
}

type FungibleItemGarageWithAddressType {
  fungibleItemId: String
  addr: Address
  item: FungibleItemType
  count: Int
}

type FungibleItemType {
  # Item category.
  itemType: ItemType!

  # Item sub category.
  itemSubType: ItemSubType!
  fungibleItemId: String!
}

# The currency type.
enum CurrencyEnum {
  CRYSTAL
  NCG
  GARAGE
}

type TransferNCGHistoryType {
  blockHash: ByteString!
  txId: ByteString!
  sender: Address!
  recipient: Address!
  amount: String!
  memo: String
}

type KeyStoreType {
  protectedPrivateKeys: [ProtectedPrivateKeyType!]!
  decryptedPrivateKey(address: Address!, passphrase: String!): ByteString!

  # An API to provide conversion to public-key, address.
  privateKey(
    # A representation of public-key with hexadecimal format.
    hex: ByteString!
  ): PrivateKeyType!
}

type ProtectedPrivateKeyType {
  address: Address!
}

type PrivateKeyType {
  # A representation of private-key with hexadecimal format.
  hex: ByteString!

  # A public-key derived from the private-key.
  publicKey: PublicKeyType!
}

type PublicKeyType {
  # A representation of public-key with hexadecimal format.
  hex(
    # A flag to determine whether to compress public-key.
    compress: Boolean
  ): ByteString!

  # An address derived from the public-key.
  address: Address!
}

type NodeStatusType {
  # Whether the current libplanet node has ended bootstrapping.
  bootstrapEnded: Boolean!

  # Whether the current libplanet node has ended preloading.
  preloadEnded: Boolean!

  # Block header of the tip block from the current canonical chain.
  tip: BlockHeader!

  # The topmost blocks from the current node.
  topmostBlocks(
    # The number of blocks to get.
    limit: Int!

    # The number of blocks to skip from tip.
    offset: Int = 0

    # List only blocks mined by the given address.  (List everything if omitted.)
    miner: Address
  ): [BlockHeader]!

  # Ids of staged transactions from the current node.
  stagedTxIds(
    # Target address to query
    address: Address
  ): [TxId]

  # The number of ids of staged transactions from the current node.
  stagedTxIdsCount: Int

  # Block header of the genesis block from the current chain.
  genesis: BlockHeader!

  # Whether the current node is mining.
  isMining: Boolean!
  appProtocolVersion: AppProtocolVersionType

  # A list of subscribers' address
  subscriberAddresses: [Address]

  # The number of a list of subscribers' address
  subscriberAddressesCount: Int

  # A version of NineChronicles.Headless
  productVersion: String

  # A informational version (a.k.a. version suffix) of NineChronicles.Headless
  informationalVersion: String
}

type BlockHeader {
  index: Int!
  id: ID!
  hash: String!
  miner: Address
}

scalar TxId

type AppProtocolVersionType {
  version: Int!
  signer: Address!
  signature: ByteString!
  extra: ByteString
}

type ExplorerQuery {
  blockQuery: BlockQuery
  transactionQuery: TransactionQuery
  stateQuery: LibplanetStateQuery
  nodeState: NodeState!
}

type BlockQuery {
  blocks(
    desc: Boolean = false
    offset: Int = 0
    limit: Int
    excludeEmptyTxs: Boolean = false
    miner: Address
  ): [Block!]!
  block(hash: ID, index: ID): Block
}

type Block {
  # A block's hash.
  hash: ID!

  # The height of the block.
  index: Long!

  # The address of the miner.
  miner: Address!

  # The public key of the Miner.
  publicKey: PublicKey

  # The previous block.  If it's a genesis block (i.e., its index is 0) this must be null.
  previousBlock: Block
  timestamp: DateTimeOffset!

  # The hash of the resulting states after evaluating transactions and a block action (if exists)
  stateRootHash: ByteString!

  # The digital signature of the whole block content (except for hash, which is derived from the signature and other contents)
  signature: ByteString

  # Transactions belonging to the block.
  transactions: [Transaction!]!

  # The LastCommit of the block.
  lastCommit: BlockCommit

  # The mining difficulty that the block's nonce has to satisfy.
  difficulty: Long!
    @deprecated(reason: "Block does not have Difficulty field in PBFT.")

  # The total mining difficulty since the genesis including the block's difficulty.
  totalDifficulty: BigInt!
    @deprecated(reason: "Block does not have TotalDifficulty field in PBFT.")

  # The proof-of-work nonce which satisfies the required difficulty.
  nonce: ByteString!
    @deprecated(reason: "Block does not have Nonce field in PBFT.")

  # The hash of PreEvaluationBlock.
  preEvaluationHash: ByteString!
}

scalar PublicKey

# The `DateTimeOffset` scalar type represents a date, time and offset from UTC. `DateTimeOffset` expects timestamps to be formatted in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard.
scalar DateTimeOffset

type Transaction {
  # A unique identifier derived from this transaction content.
  id: ID!

  # The number of previous transactions committed by the signer of this tx.
  nonce: Long!

  # An address of the account who signed this transaction.
  signer: Address!

  # A PublicKey of the account who signed this transaction.
  publicKey: ByteString!

  # Addresses whose states were affected by Actions.
  updatedAddresses: [Address!]!

  # A digital signature of the content of this transaction.
  signature: ByteString!

  # The time this transaction was created and signed.
  timestamp: DateTimeOffset!

  # A list of actions in this transaction.
  actions: [Action!]!

  # A serialized tx payload in base64 string.
  serializedPayload: String!

  # The block including the transaction.
  blockRef: Block!
}

type Action {
  # Raw Action data ('hex' or 'base64' encoding available.)
  raw(encode: String = "hex"): String!

  # A readable representation for debugging.
  inspection: String!

  # A JSON representation of action data
  json: String!
}

type BlockCommit {
  # The height of the block commit.
  height: Long!

  # The round of the block commit.
  round: Int!

  # The hash of the block which contains block commit.
  blockHash: ID!

  # Total votes of the block commit.
  votes: [Vote!]!
}

type Vote {
  # Height of the consensus voted.
  height: Long!

  # Round of the consensus voted.
  round: Int!

  # Hash of the block voted.
  blockHash: String!

  # The time this vote was created and signed.
  timestamp: DateTimeOffset!

  # Public key of the validator which is subject of the vote.
  validatorPublicKey: PublicKey!

  # Flag of the vote
  flag: VoteFlag!

  # A digital signature of the content of this vote.
  signature: ByteString!
}

scalar VoteFlag

type TransactionQuery {
  transactions(
    signer: Address
    involvedAddress: Address
    desc: Boolean = false
    offset: Int = 0
    limit: Int
  ): [Transaction!]!
  stagedTransactions(
    signer: Address
    involvedAddress: Address
    desc: Boolean = false
    offset: Int = 0
    limit: Int
  ): [Transaction!]!
  transaction(id: ID): Transaction
  unsignedTransaction(
    # The hexadecimal string of public key for Transaction.
    publicKey: String!

    # The hexadecimal string of plain value for Action.
    plainValue: String!

    # The nonce for Transaction.
    nonce: Long
  ): ByteString!
  nextNonce(
    # Address of the account to get the next tx nonce.
    address: Address!
  ): Long!

  # Attach the given signature to the given transaction and return tx as hexadecimal
  bindSignature(
    # The hexadecimal string of unsigned transaction to attach the given signature.
    unsignedTransaction: String!

    # The hexadecimal string of the given unsigned transaction.
    signature: String!
  ): String!
  transactionResult(
    # transaction id.
    txId: ID!
  ): TxResultType!
}

type TxResultType {
  # The transaction status.
  txStatus: TxStatus!

  # The block index which the target transaction executed.
  blockIndex: Long

  # The block hash which the target transaction executed.
  blockHash: String

  # The name of exception. (when only failed)
  exceptionName: String

  # The hexadecimal string of the exception metadata. (when only failed)
  exceptionMetadata: BencodexValue
  updatedStates: [UpdatedStateType!]
  updatedFungibleAssets: [FungibleAssetBalancesType!]
  fungibleAssetsDelta: [FungibleAssetBalancesType!]
}

enum TxStatus {
  INVALID
  STAGING
  SUCCESS
  FAILURE
}

scalar BencodexValue

type UpdatedStateType {
  address: Address!
  state: BencodexValue
}

type FungibleAssetBalancesType {
  address: Address!
  fungibleAssetValues: [FungibleAssetValue!]!
}

type LibplanetStateQuery {
  states(addresses: [Address!]!, offsetBlockHash: ID!): [BencodexValue]!
  balance(
    owner: Address!
    currency: CurrencyInput!
    offsetBlockHash: ID!
  ): FungibleAssetValue!
  totalSupply(
    currency: CurrencyInput!
    offsetBlockHash: ID!
  ): FungibleAssetValue
  validators(offsetBlockHash: ID!): [Validator!]
}

# A data type holds validator's public key and its voting power.
type Validator {
  # The public key of the validator.
  publicKey: PublicKey!

  # Gets the voting power of the validator.
  power: BigInt!
}

type NodeState {
  preloaded: Boolean!
  peers: [BoundPeer!]
  validators: [BoundPeer!]
}

type BoundPeer {
  # The public key of the peer.
  publicKey: PublicKey!

  # The endpoint of the peer.
  endPoint: String!

  # The address of the miner.
  publicIpAddress: String
}

type ValidationQuery {
  metadata(
    # The raw value of json metadata.
    raw: String!
  ): Boolean!
  privateKey(
    # The raw value of private-key, presented as hexadecimal.
    hex: ByteString!
  ): Boolean!
  publicKey(
    # The raw value of public-key, presented as hexadecimal.
    hex: ByteString!
  ): Boolean!
}

type ActivationStatusQuery {
  activated: Boolean!
    @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")
  addressActivated(address: Address!): Boolean!
    @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")
}

type PeerChainStateQuery {
  # Summary of other peers connected to this node. It consists of address, chain height, and total difficulty.
  state: [String]!
}

type TransactionType {
  # A unique identifier derived from this transaction content.
  id: TxId!

  # The number of previous transactions committed by the signer of this transaction.
  nonce: Long!

  # A PublicKey of the account who signed this transaction.
  publicKey: PublicKeyType!

  # A digital signature of the content of this transaction.
  signature: ByteString!

  # An address of the account who signed this transaction.
  signer: Address!

  # The time this transaction was created and signed.
  timestamp: String!

  # Addresses whose states were affected by Actions.
  updatedAddresses: [Address]!

  # A list of actions in this transaction.
  actions: [Action]!
}

type MonsterCollectionStatusType {
  fungibleAssetValue: FungibleAssetValueType!
  rewardInfos: [MonsterCollectionRewardInfoType]
  tipIndex: Long!
  lockup: Boolean!
}

type FungibleAssetValueType {
  currency: String!
  quantity: String!
}

type TransactionHeadlessQuery {
  nextTxNonce(
    # Target address to query
    address: Address!
  ): Long!
  getTx(
    # transaction id.
    txId: TxId!
  ): TransactionType
  createUnsignedTx(
    # The base64-encoded public key for Transaction.
    publicKey: String!

    # The base64-encoded plain value of action for Transaction.
    plainValue: String!

    # The nonce for Transaction.
    nonce: Long
  ): String!
    @deprecated(reason: "API update with action query. use unsignedTransaction")
  attachSignature(
    # The base64-encoded unsigned transaction to attach the given signature.
    unsignedTransaction: String!

    # The base64-encoded signature of the given unsigned transaction.
    signature: String!
  ): String! @deprecated(reason: "Use signTransaction")
  transactionResult(
    # transaction id.
    txId: TxId!
  ): TxResultType!
  unsignedTransaction(
    # The hexadecimal string of public key for Transaction.
    publicKey: String!

    # The hexadecimal string of plain value for Action.
    plainValue: String!

    # The nonce for Transaction.
    nonce: Long
    maxGasPrice: FungibleAssetValueInputType = {
      quantity: 1000000000000000000
      ticker: "Mead"
      decimalPlaces: 18
      minters: null
    }
  ): ByteString!
  signTransaction(
    # The hexadecimal string of unsigned transaction to attach the given signature.
    unsignedTransaction: String!

    # The hexadecimal string of signature of the given unsigned transaction.
    signature: String!
  ): ByteString!
}

input FungibleAssetValueInputType {
  quantity: BigInt!
  ticker: String!
  decimalPlaces: Byte!
  minters: [Address!]
}

type RpcInformationQuery {
  # total count by connected to this node.
  totalCount: Int!

  # List of address connected to this node.
  clients: [Address]!

  # total count by connected to this node.
  totalCountByDevice(device: String!): Int!

  # clients connected to this node by device.
  clientsByDevice(device: String!): [Address!]!
}

type ActionQuery {
  stake(
    # An amount to stake.
    amount: BigInt
  ): ByteString
  claimStakeReward(
    # The avatar address to receive staking rewards.
    avatarAddress: Address
  ): ByteString
  migrateMonsterCollection(
    # The avatar address to receive monster collection rewards.
    avatarAddress: Address
  ): ByteString!
  grinding(
    # Address of avatar.
    avatarAddress: Address!

    # List of equipment ItemId.
    equipmentIds: [Guid]!

    # Flag to Charge Action Point.
    chargeAp: Boolean
  ): ByteString
  unlockEquipmentRecipe(
    # Address of avatar.
    avatarAddress: Address!

    # List of EquipmentRecipeSheet row ids to unlock.
    recipeIds: [Int]!
  ): ByteString
  unlockWorld(
    # Address of avatar.
    avatarAddress: Address!

    # List of WorldUnlockSheet row world_id_to_unlock.
    worldIds: [Int]!
  ): ByteString
  transferAsset(
    # Address of sender.
    sender: Address!

    # Address of recipient.
    recipient: Address!

    # A string value to be transferred.
    amount: String!

    # A currency type to be transferred.
    currency: CurrencyEnum!

    # A 80-max length string to note.
    memo: String
  ): ByteString
  patchTableSheet(
    # name of table sheet.
    tableName: String!

    # table data.
    tableCsv: String!
  ): ByteString!
  raid(
    # address of avatar state.
    avatarAddress: Address!

    # list of equipment id.
    equipmentIds: [Guid] = []

    # list of costume id.
    costumeIds: [Guid] = []

    # list of food id.
    foodIds: [Guid] = []

    # refill ticket by NCG.
    payNcg: Boolean = false

    # list of rune slot
    runeSlotInfos: [RuneSlotInfoInputType!] = []
  ): ByteString!
  claimRaidReward(
    # address of avatar state to receive reward.
    avatarAddress: Address!
  ): ByteString!
  claimWorldBossKillReward(
    # address of avatar state to receive reward.
    avatarAddress: Address!
  ): ByteString!
  prepareRewardAssets(
    # address of reward pool for charge reward.
    rewardPoolAddress: Address!

    # list of FungibleAssetValue for charge reward.
    assets: [FungibleAssetValueInputType!]!
  ): ByteString!
  transferAssets(
    # Address of sender.
    sender: Address!

    # List of tuples that recipients' address and asset amount to be sent
    recipients: [RecipientsInputType!]!

    # A 80-max length string to note.
    memo: String
  ): ByteString!
  activateAccount(
    # Activation code that you've get.
    activationCode: String!
  ): ByteString!
    @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")
  createAvatar(
    # index of avatar in `AgentState.avatarAddresses`.(0~2)
    index: Int!

    # name of avatar.(2~20 characters)
    name: String!

    # hair index of avatar.
    hair: Int = 0

    # lens index of avatar.
    lens: Int = 0

    # ear index of avatar.
    ear: Int = 0

    # tail index of avatar.
    tail: Int = 0
  ): ByteString!
  runeEnhancement(
    # The avatar address to enhance rune.
    avatarAddress: Address!

    # Rune ID to enhance.
    runeId: Int!

    # The try count to enhance rune
    tryCount: Int
  ): ByteString!
  hackAndSlash(
    # Avatar address.
    avatarAddress: Address!

    # World ID containing the stage ID.
    worldId: Int!

    # Stage ID.
    stageId: Int!

    # List of costume id for equip.
    costumeIds: [Guid]

    # List of equipment id for equip.
    equipmentIds: [Guid]

    # List of consumable id for use.
    consumableIds: [Guid]

    # List of rune slot info for equip.
    runeSlotInfos: [RuneSlotInfoInputType!] = []

    # Buff ID for this stage
    stageBuffId: Int
  ): ByteString!
  hackAndSlashSweep(
    # Avatar address.
    avatarAddress: Address!

    # World ID containing the stage ID.
    worldId: Int!

    # Stage ID.
    stageId: Int!

    # List of costume id for equip.
    costumeIds: [Guid]

    # List of equipment id for equip.
    equipmentIds: [Guid]

    # List of rune slot info for equip.
    runeSlotInfos: [RuneSlotInfoInputType!] = []

    # Action point usage to sweep
    actionPoint: Int!

    # AP stone usage to sweep
    apStoneCount: Int
  ): ByteString!
  dailyReward(
    # Avatar address to get daily reward
    avatarAddress: Address!
  ): ByteString!
  combinationEquipment(
    # Avatar address to combine equipment
    avatarAddress: Address!

    # Slot index to combine equipment
    slotIndex: Int!

    # Combination recipe ID
    recipeId: Int!

    # Sub-recipe ID of this combination
    subRecipeId: Int

    # Pay crystal co combine equipment?
    payByCrystal: Boolean

    # Use hammer point to combine equipment?
    useHammerPoint: Boolean
  ): ByteString!
  itemEnhancement(
    # Avatar address to enhance item
    avatarAddress: Address!

    # Slot index to enhance item
    slotIndex: Int!

    # Target item ID to enhance
    itemId: Guid!

    # Material ID to enhance
    materialId: Guid!
  ): ByteString!
  rapidCombination(
    # Avatar address to execute rapid combination
    avatarAddress: Address!

    # Slot index to execute rapid
    slotIndex: Int!
  ): ByteString!
  combinationConsumable(
    # Avatar address to combine consumable
    avatarAddress: Address!

    # Slot index to combine
    slotIndex: Int!

    # Recipe ID to combine consumable
    recipeId: Int!
  ): ByteString!
  requestPledge(agentAddress: Address!, mead: Int = 4): ByteString!
  approvePledge(patronAddress: Address!): ByteString!
  endPledge(agentAddress: Address!): ByteString!
  createPledge(
    patronAddress: Address!
    agentAddresses: [Address!]!
    mead: Int = 4
  ): ByteString!
  loadIntoMyGarages(
    # Array of balance address and currency ticker and quantity.
    fungibleAssetValues: [BalanceInput!]

    # Inventory Address
    inventoryAddr: Address

    # Array of fungible ID and count
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    # Memo
    memo: String
  ): ByteString!
  deliverToOthersGarages(
    # Recipient agent address
    recipientAgentAddr: Address!

    # Array of currency ticket and quantity to deliver.
    fungibleAssetValues: [SimplifyFungibleAssetValueInput!]

    # Array of Fungible ID and count to deliver.
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    # Memo
    memo: String
  ): ByteString!
  unloadFromMyGarages(
    # Recipient avatar address
    recipientAvatarAddr: Address!

    # Array of balance address and currency ticker and quantity to send.
    fungibleAssetValues: [BalanceInput!]

    # Array of fungible ID and count to send.
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    # Memo
    memo: String
  ): ByteString!

  # Query to craft/enhance items/foods
  craftQuery: CraftQuery!
}

input RuneSlotInfoInputType {
  slotIndex: Int!
  runeId: Int!
}

input RecipientsInputType {
  recipient: Address!
  amount: FungibleAssetValueInputType!
}

input BalanceInput {
  # Balance Address.
  balanceAddr: Address

  # Fungible asset value ticker and amount.
  value: SimplifyFungibleAssetValueInput
}

# A fungible asset value ticker and amount.You can specify either currencyEnum or currencyTicker.
input SimplifyFungibleAssetValueInput {
  # A currency type to be loaded.
  currencyEnum: CurrencyEnum

  # A currency ticker to be loaded.
  currencyTicker: String

  # A numeric string to parse.  Can consist of digits, plus (+), minus (-), and decimal separator (.). <see cref="FungibleAssetValue.Parse(Currency, string)" />
  value: String!
}

input FungibleIdAndCountInput {
  # Fungible ID
  fungibleId: String!

  # Count
  count: Int!
}

type CraftQuery {
  eventConsumableItemCrafts(
    # Avatar address to craft event item
    avatarAddress: Address!

    # The ID of event schedule
    eventScheduleId: Int!

    # Recipe ID of event item to craft
    eventConsumableItemRecipeId: Int!

    # Target slot index to craft item
    slotIndex: Int!
  ): ByteString!
  eventMaterialItemCrafts(
    # Avatar address to craft item
    avatarAddress: Address!

    # The ID of event schedule
    eventScheduleId: Int!

    # Recipe ID of event item to craft
    eventMaterialItemRecipeId: Int!

    # Materials to be used to craft
    materialsToUse: [MaterialsToUseInputType!]!
  ): ByteString!
}

input MaterialsToUseInputType {
  # Material ID to be used.
  materialId: Int!

  # Item quantity to be used.
  quantity: Int!
}

type ActionTxQuery {
  stake(
    # An amount to stake.
    amount: BigInt
  ): ByteString
  claimStakeReward(
    # The avatar address to receive staking rewards.
    avatarAddress: Address
  ): ByteString
  migrateMonsterCollection(
    # The avatar address to receive monster collection rewards.
    avatarAddress: Address
  ): ByteString!
  grinding(
    # Address of avatar.
    avatarAddress: Address!

    # List of equipment ItemId.
    equipmentIds: [Guid]!

    # Flag to Charge Action Point.
    chargeAp: Boolean
  ): ByteString
  unlockEquipmentRecipe(
    # Address of avatar.
    avatarAddress: Address!

    # List of EquipmentRecipeSheet row ids to unlock.
    recipeIds: [Int]!
  ): ByteString
  unlockWorld(
    # Address of avatar.
    avatarAddress: Address!

    # List of WorldUnlockSheet row world_id_to_unlock.
    worldIds: [Int]!
  ): ByteString
  transferAsset(
    # Address of sender.
    sender: Address!

    # Address of recipient.
    recipient: Address!

    # A string value to be transferred.
    amount: String!

    # A currency type to be transferred.
    currency: CurrencyEnum!

    # A 80-max length string to note.
    memo: String
  ): ByteString
  patchTableSheet(
    # name of table sheet.
    tableName: String!

    # table data.
    tableCsv: String!
  ): ByteString!
  raid(
    # address of avatar state.
    avatarAddress: Address!

    # list of equipment id.
    equipmentIds: [Guid] = []

    # list of costume id.
    costumeIds: [Guid] = []

    # list of food id.
    foodIds: [Guid] = []

    # refill ticket by NCG.
    payNcg: Boolean = false

    # list of rune slot
    runeSlotInfos: [RuneSlotInfoInputType!] = []
  ): ByteString!
  claimRaidReward(
    # address of avatar state to receive reward.
    avatarAddress: Address!
  ): ByteString!
  claimWorldBossKillReward(
    # address of avatar state to receive reward.
    avatarAddress: Address!
  ): ByteString!
  prepareRewardAssets(
    # address of reward pool for charge reward.
    rewardPoolAddress: Address!

    # list of FungibleAssetValue for charge reward.
    assets: [FungibleAssetValueInputType!]!
  ): ByteString!
  transferAssets(
    # Address of sender.
    sender: Address!

    # List of tuples that recipients' address and asset amount to be sent
    recipients: [RecipientsInputType!]!

    # A 80-max length string to note.
    memo: String
  ): ByteString!
  activateAccount(
    # Activation code that you've get.
    activationCode: String!
  ): ByteString!
    @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")
  createAvatar(
    # index of avatar in `AgentState.avatarAddresses`.(0~2)
    index: Int!

    # name of avatar.(2~20 characters)
    name: String!

    # hair index of avatar.
    hair: Int = 0

    # lens index of avatar.
    lens: Int = 0

    # ear index of avatar.
    ear: Int = 0

    # tail index of avatar.
    tail: Int = 0
  ): ByteString!
  runeEnhancement(
    # The avatar address to enhance rune.
    avatarAddress: Address!

    # Rune ID to enhance.
    runeId: Int!

    # The try count to enhance rune
    tryCount: Int
  ): ByteString!
  hackAndSlash(
    # Avatar address.
    avatarAddress: Address!

    # World ID containing the stage ID.
    worldId: Int!

    # Stage ID.
    stageId: Int!

    # List of costume id for equip.
    costumeIds: [Guid]

    # List of equipment id for equip.
    equipmentIds: [Guid]

    # List of consumable id for use.
    consumableIds: [Guid]

    # List of rune slot info for equip.
    runeSlotInfos: [RuneSlotInfoInputType!] = []

    # Buff ID for this stage
    stageBuffId: Int
  ): ByteString!
  hackAndSlashSweep(
    # Avatar address.
    avatarAddress: Address!

    # World ID containing the stage ID.
    worldId: Int!

    # Stage ID.
    stageId: Int!

    # List of costume id for equip.
    costumeIds: [Guid]

    # List of equipment id for equip.
    equipmentIds: [Guid]

    # List of rune slot info for equip.
    runeSlotInfos: [RuneSlotInfoInputType!] = []

    # Action point usage to sweep
    actionPoint: Int!

    # AP stone usage to sweep
    apStoneCount: Int
  ): ByteString!
  dailyReward(
    # Avatar address to get daily reward
    avatarAddress: Address!
  ): ByteString!
  combinationEquipment(
    # Avatar address to combine equipment
    avatarAddress: Address!

    # Slot index to combine equipment
    slotIndex: Int!

    # Combination recipe ID
    recipeId: Int!

    # Sub-recipe ID of this combination
    subRecipeId: Int

    # Pay crystal co combine equipment?
    payByCrystal: Boolean

    # Use hammer point to combine equipment?
    useHammerPoint: Boolean
  ): ByteString!
  itemEnhancement(
    # Avatar address to enhance item
    avatarAddress: Address!

    # Slot index to enhance item
    slotIndex: Int!

    # Target item ID to enhance
    itemId: Guid!

    # Material ID to enhance
    materialId: Guid!
  ): ByteString!
  rapidCombination(
    # Avatar address to execute rapid combination
    avatarAddress: Address!

    # Slot index to execute rapid
    slotIndex: Int!
  ): ByteString!
  combinationConsumable(
    # Avatar address to combine consumable
    avatarAddress: Address!

    # Slot index to combine
    slotIndex: Int!

    # Recipe ID to combine consumable
    recipeId: Int!
  ): ByteString!
  requestPledge(agentAddress: Address!, mead: Int = 4): ByteString!
  approvePledge(patronAddress: Address!): ByteString!
  endPledge(agentAddress: Address!): ByteString!
  createPledge(
    patronAddress: Address!
    agentAddresses: [Address!]!
    mead: Int = 4
  ): ByteString!
  loadIntoMyGarages(
    # Array of balance address and currency ticker and quantity.
    fungibleAssetValues: [BalanceInput!]

    # Inventory Address
    inventoryAddr: Address

    # Array of fungible ID and count
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    # Memo
    memo: String
  ): ByteString!
  deliverToOthersGarages(
    # Recipient agent address
    recipientAgentAddr: Address!

    # Array of currency ticket and quantity to deliver.
    fungibleAssetValues: [SimplifyFungibleAssetValueInput!]

    # Array of Fungible ID and count to deliver.
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    # Memo
    memo: String
  ): ByteString!
  unloadFromMyGarages(
    # Recipient avatar address
    recipientAvatarAddr: Address!

    # Array of balance address and currency ticker and quantity to send.
    fungibleAssetValues: [BalanceInput!]

    # Array of fungible ID and count to send.
    fungibleIdAndCounts: [FungibleIdAndCountInput!]

    # Memo
    memo: String
  ): ByteString!

  # Query to craft/enhance items/foods
  craftQuery: CraftQuery!
}

type AddressQuery {
  # user information address by world boss season.
  raiderAddress(
    # address of avatar state.
    avatarAddress: Address!

    # world boss season id.
    raidId: Int!
  ): Address!

  # boss information address by world boss season.
  worldBossAddress(
    # world boss season id.
    raidId: Int!
  ): Address!

  # user boss kill reward record address by world boss season.
  worldBossKillRewardRecordAddress(
    # address of avatar state.
    avatarAddress: Address!

    # world boss season id.
    raidId: Int!
  ): Address!

  # raider list address by world boss season.
  raiderListAddress(
    # world boss season id.
    raidId: Int!
  ): Address!

  # currency minters address.
  currencyMintersAddress(
    # A currency type. see also: https://github.com/planetarium/NineChronicles.Headless/blob/main/NineChronicles.Headless/GraphTypes/CurrencyEnumType.cs
    currency: CurrencyEnum!
  ): [Address!]

  # pledge information address.
  pledgeAddress(
    # address of agent state.
    agentAddress: Address!
  ): Address!
}

type StandaloneMutation {
  keyStore: KeyStoreMutation
    @deprecated(
      reason: "Use `planet key` command instead.  https://www.npmjs.com/package/@planetarium/cli"
    )
  activationStatus: ActivationStatusMutation
    @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")
  action: ActionMutation

  # Add a new transaction to staging
  stageTx(
    # The base64-encoded bytes for new transaction.
    payload: String!
  ): Boolean!

  # Add a new transaction to staging and return TxId
  stageTxV2(
    # The base64-encoded bytes for new transaction.
    payload: String!
  ): TxId!
    @deprecated(
      reason: "API update with action query. use stageTransaction mutation"
    )
  transfer(
    # A hex-encoded value for address of recipient.
    recipient: Address!

    # A string value of the value to be transferred.
    amount: String!

    # A sender's transaction counter. You can get it through nextTxNonce().
    txNonce: Long!

    # A hex-encoded value for address of currency to be transferred. The default is the NCG's address.
    currencyAddress: String! = "000000000000000000000000000000000000000A"

    # A 80-max length string to note.
    memo: String
  ): TxId
  transferGold(recipient: Address!, amount: String!): TxId
    @deprecated(
      reason: "Incorrect remittance may occur when using transferGold() to the same address consecutively. Use transfer() instead."
    )

  # Add a new transaction to staging and return TxId
  stageTransaction(
    # The hexadecimal string of the transaction to stage.
    payload: String!
  ): TxId!
}

type KeyStoreMutation {
  createPrivateKey(passphrase: String!, privateKey: ByteString): PrivateKeyType!
  revokePrivateKey(address: Address!): ProtectedPrivateKeyType!
}

type ActivationStatusMutation {
  activateAccount(encodedActivationKey: String!): Boolean!
    @deprecated(reason: "Since NCIP-15, it doesn't care account activation.")
}

type ActionMutation {
  # Create new avatar.
  createAvatar(
    # Avatar name.
    avatarName: String!

    # The index of character slot. 0 ~ 2
    avatarIndex: Int!

    # The index of character hair color. 0 ~ 8
    hairIndex: Int!

    # The index of character eye color. 0 ~ 8
    lensIndex: Int!

    # The index of character ear color. 0 ~ 8
    earIndex: Int!

    # The index of character tail color. 0 ~ 8
    tailIndex: Int!
  ): TxId!

  # Start stage to get material.
  hackAndSlash(
    # Avatar address.
    avatarAddress: Address!

    # World ID containing the stage ID.
    worldId: Int!

    # Stage ID.
    stageId: Int!

    # List of costume id for equip.
    costumeIds: [Guid]

    # List of equipment id for equip.
    equipmentIds: [Guid]

    # List of consumable id for use.
    consumableIds: [Guid]

    # List of rune slot info for equip.
    runeSlotInfos: [RuneSlotInfoInputType!] = []
  ): TxId!

  # Combine new equipment.
  combinationEquipment(
    # Avatar address to create equipment.
    avatarAddress: Address!

    # EquipmentRecipe ID from EquipmentRecipeSheet.
    recipeId: Int!

    # The empty combination slot index to combine equipment. 0 ~ 3
    slotIndex: Int!

    # EquipmentSubRecipe ID from EquipmentSubRecipeSheet.
    subRecipeId: Int
  ): TxId!

  # Upgrade equipment.
  itemEnhancement(
    # Avatar address to upgrade equipment.
    avatarAddress: Address!

    # Equipment Guid for upgrade.
    itemId: Guid!

    # Material Guid for equipment upgrade.
    materialId: Guid!

    # The empty combination slot index to upgrade equipment. 0 ~ 3
    slotIndex: Int!
  ): TxId!

  # Get daily reward.
  dailyReward(
    # Avatar address to receive reward.
    avatarAddress: Address!
  ): TxId!

  # Charge Action Points using Material.
  chargeActionPoint(
    # Avatar to use potion.
    avatarAddress: Address!
  ): TxId!

  # Combine new Consumable.
  combinationConsumable(
    # Avatar address to combine consumable.
    avatarAddress: Address!

    # ConsumableRecipe ID from ConsumableRecipeSheet.
    recipeId: Int!

    # The empty combination slot index to combine consumable. 0 ~ 3
    slotIndex: Int!
  ): TxId!

  # Start monster collect.
  monsterCollect(
    # The monster collection level.(1 ~ 7)
    level: Int!
  ): TxId!

  # Get monster collection reward.
  claimMonsterCollectionReward(
    # Address of avatar for get reward.
    avatarAddress: Address!
  ): TxId!
}

type StandaloneSubscription {
  tipChanged: TipChanged
  preloadProgress: PreloadStateType
  nodeStatus: NodeStatusType
  differentAppProtocolVersionEncounter: DifferentAppProtocolVersionEncounterType!
  notification: NotificationType!
  nodeException: NodeExceptionType!
  balanceByAgent(
    # A hex-encoded address of agent.
    address: Address!
  ): String!
}

type TipChanged {
  index: Long!
  hash: ByteString
}

type PreloadStateType {
  currentPhase: Long!
  totalPhase: Long!
  extra: PreloadStateExtraType!
}

type PreloadStateExtraType {
  type: String!
  currentCount: Long!
  totalCount: Long!
}

type DifferentAppProtocolVersionEncounterType {
  peer: String!
  peerVersion: AppProtocolVersionType!
  localVersion: AppProtocolVersionType!
}

type NotificationType {
  # The type of Notification.
  type: NotificationEnum!

  # The message of Notification.
  message: String
}

enum NotificationEnum {
  REFILL
  HAS
  COMBINATION_EQUIPMENT
  COMBINATION_CONSUMABLE
  BUYER
  SELLER
}

type NodeExceptionType {
  # The code of NodeException.
  code: Int!

  # The message of NodeException.
  message: String!
}
